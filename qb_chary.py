
"""QB Chart.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rIIHTO-49-JFJMrMi087oR4rrYuBJUUw
"""
import streamlit as st
st.title("QB Pass Chart V0.3.1")

import matplotlib.pyplot as plt
import pandas as pd
from matplotlib.lines import Line2D

fig, ax = plt.subplots(figsize=(6, 4))
ax.set_title("3rd & 3 ‚Äì Red Zone vs SEA (Cover 3, MOF Closed)")

st.subheader("üìã Key Scouting Plays")




# Funci√≥n para dibujar el campo de f√∫tbol
def draw_football_field(ax):
    ax.set_facecolor('black')
    ax.plot([0, 53.3, 53.3, 0, 0], [-10, -10, 60, 60, -10], color='white', linewidth=2)

    for y in range(-10, 61, 10):
        ax.axhline(y, color='white', linewidth=1)

    for y in [-5, 5, 15, 25, 35, 45, 55]:
        ax.axhline(y, color='white', linewidth=0.75, linestyle='-')

    for y in [-10, 10, 20, 30, 40, 50, 60]:
        ax.text(8, y-0.84, f"{y}", fontsize=15, color='white', ha='center', rotation=270, linespacing=3.2)
        ax.text(45, y-0.42, f"{y}", fontsize=15, color='white', ha='center', rotation=90, linespacing=3.2)

    for y in range(-10, 61):
        if y % 5 != 0:
            ax.plot([19, 20], [y, y], color='white', linewidth=1)
            ax.plot([33, 34], [y, y], color='white', linewidth=1)

def compute_summary(df_in: pd.DataFrame) -> dict:
    if df_in is None or df_in.empty:
        return {"att": 0, "comp": 0, "comp_pct": 0.0, "td": 0, "int": 0, "drop": 0, "avg_depth": 0.0}

    df2 = df_in.copy()
    df2["DEPTH"] = df2["Target Y 100"] - df2["SPOT Y 100"]

    att = len(df2)
    comp = int((df2["COM"] == 1).sum()) if "COM" in df2.columns else 0
    comp_pct = (comp / att * 100) if att > 0 else 0.0

    outcome = df2["TD/INT"].astype(str).str.upper().str.strip() if "TD/INT" in df2.columns else pd.Series([""] * att)
    td = int((outcome == "TD").sum())
    it = int((outcome == "INT").sum())
    drop = int((outcome == "DROP").sum())

    avg_depth = float(df2["DEPTH"].mean()) if att > 0 else 0.0

    return {"att": att, "comp": comp, "comp_pct": comp_pct, "td": td, "int": it, "drop": drop, "avg_depth": avg_depth}

import numpy as np

rng = np.random.default_rng(42)  # cambia el 42 si quieres otra ‚Äútemporada‚Äù

def assign_coverage(row):
    dn = row.get("DN", None)
    dist = row.get("DIST", None)

    # si falta info, usa distribuci√≥n base
    if pd.isna(dn) or pd.isna(dist):
        return rng.choice(
            ["Cover 3", "Cover 1", "Cover 2", "Cover 4", "Cover 6", "Blitz", "2 Man", "Cover 0"],
            p=[0.30, 0.20, 0.15, 0.12, 0.08, 0.07, 0.05, 0.03]
        )

    dn = int(dn)
    dist = float(dist)

    # 3rd/4th & long: m√°s 2-high / quarters / split safety
    if dn in (3, 4) and dist >= 7:
        return rng.choice(
            ["Cover 2", "Cover 4", "Cover 6", "2 Man", "Cover 3", "Cover 1", "Blitz"],
            p=[0.22, 0.26, 0.16, 0.10, 0.12, 0.08, 0.06]
        )

    # 3rd/4th & short: m√°s man, presi√≥n, single-high
    if dn in (3, 4) and dist <= 2:
        return rng.choice(
            ["Cover 1", "Blitz", "Cover 0", "Cover 3", "2 Man"],
            p=[0.40, 0.30, 0.12, 0.12, 0.06]
        )

    # 1st down: mucho Cover 3 / 1, algo de 2/4
    if dn == 1:
        return rng.choice(
            ["Cover 3", "Cover 1", "Cover 2", "Cover 4", "Cover 6", "Blitz", "2 Man", "Cover 0"],
            p=[0.34, 0.22, 0.14, 0.12, 0.07, 0.06, 0.03, 0.02]
        )

    # 2nd down: mezcla
    return rng.choice(
        ["Cover 3", "Cover 1", "Cover 2", "Cover 4", "Cover 6", "Blitz", "2 Man", "Cover 0"],
        p=[0.30, 0.20, 0.16, 0.12, 0.08, 0.08, 0.04, 0.02]
    )

def coverage_to_mof(cov: str) -> str:
    """
    MOF Open ~ 2-high structures (Cover 2/4/6, 2 Man).
    MOF Closed ~ 1-high/0-high (Cover 1/3/0).
    Blitz puede ser cualquiera; aqu√≠ lo tratamos mayormente Closed pero a veces Open.
    """
    c = str(cov).strip().lower()

    if c in ("cover 2", "cover 4", "cover 6", "2 man"):
        return "Open"
    if c in ("cover 0", "cover 1", "cover 3"):
        return "Closed"
    if c == "blitz":
        # 70% single-high (Closed), 30% 2-high pressures (Open)
        return rng.choice(["Closed", "Open"], p=[0.70, 0.30])

    return "Unknown"



# Funci√≥n para graficar los pases filtrados
def plot_football_passes(df, down, distance_type, d1, d2, custom_title, highlight_row_id=None):
    fig, ax = plt.subplots(figsize=(8, 8))
    draw_football_field(ax)

    ax.set_xlim(0, 53.3)
    ax.set_ylim(-10, 60)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.axhline(0, color='blue', linewidth=2)
    ax.set_aspect('equal')

    title = custom_title if custom_title else "Pass Chart"
    ax.set_title(title)

    # puntos
    for _, row in df.iterrows():
        x = row['Target X 100']
        y = row['Target Y 100'] - row['SPOT Y 100']
        ax.scatter(x, y, color=row['Color'], s=80)

        if 'WR' in df.columns and not pd.isna(row['WR']):
            ax.text(x, y, str(int(row['WR'])), fontsize=6,
                    ha='center', va='center', color='black')

    # highlight (c√≠rculo blanco alrededor)
    if highlight_row_id is not None and "ROW_ID" in df.columns:
        sel = df[df["ROW_ID"] == highlight_row_id]
        if not sel.empty:
            xh = sel.iloc[0]['Target X 100']
            yh = sel.iloc[0]['Target Y 100'] - sel.iloc[0]['SPOT Y 100']
            ax.scatter(xh, yh, s=260, facecolors="none", edgecolors="white", linewidths=2.8)

    # leyenda (tuya)
    legend_elements = [
        Line2D([0], [0], marker='o', color='w', label='Completo', markerfacecolor='aqua', markersize=8),
        Line2D([0], [0], marker='o', color='w', label='Incompleto', markerfacecolor='fuchsia', markersize=8),
        Line2D([0], [0], marker='o', color='w', label='Intercepci√≥n', markerfacecolor='red', markersize=8),
        Line2D([0], [0], marker='o', color='w', label='Touchdown', markerfacecolor='lime', markersize=8),
        Line2D([0], [0], marker='o', color='w', label='Drop', markerfacecolor='yellow', markersize=8),
    ]
    leg = ax.legend(handles=legend_elements, loc='upper right',
                    frameon=True, facecolor='black', edgecolor='white')
    for t in leg.get_texts():
        t.set_color('white')

    st.pyplot(fig)

st.title("üèà Pass Chart Interactivo")

uploaded_file = st.file_uploader("Sube tu archivo CSV o Excel", type=["csv", "xlsx"])

if uploaded_file:
    df = pd.read_csv(uploaded_file) if uploaded_file.name.endswith(".csv") else pd.read_excel(uploaded_file)
    df.columns = df.columns.str.strip()
    df = df.dropna(subset=['Target X 100', 'Target Y 100'])
    df["COM"] = df["COM"].fillna(0)
    # Crear columnas (si ya existen, esto las sobreescribe para el demo)
    df["COVERAGE"] = df.apply(assign_coverage, axis=1)
    df["MOF"] = df["COVERAGE"].apply(coverage_to_mof)
    def get_color(row):
        outcome = str(row.get("TD/INT", "")).strip()
        if outcome == 'TD':
            return 'lime'
        elif outcome == 'INT':
            return 'red'
        elif outcome == 'Drop':
            return 'yellow'
        elif float(row.get("COM", 0)) == 1.0:
            return 'aqua'
        else:
            return 'fuchsia'

    df['Color'] = df.apply(get_color, axis=1)

    # --- Sidebar ---
    st.sidebar.header("Filtros")
    st.sidebar.subheader("Partidos (RIVAL)")

    rivals = sorted(df["RIVAL"].dropna().astype(str).unique().tolist()) if "RIVAL" in df.columns else []
    selected_rivals = st.sidebar.multiselect(
        "Selecciona partido(s) por RIVAL",
        options=rivals,
        default=rivals
    )

    st.sidebar.subheader("Situational Presets")


    preset = st.sidebar.radio(
        "Situaci√≥n",
        [
            "All Plays",
            "1st & 10",
            "3rd & Long",
            "3rd & Short",
            "Red Zone",
            "Backed Up"
        ]
    )



    down = st.sidebar.selectbox("Down", ["All"] + sorted(df['DN'].unique()))
    distance_type = st.sidebar.selectbox("Tipo de distancia", ["Greater than", "Equal to", "Less than", "Between"])
    d1 = st.sidebar.number_input("Distancia 1", 0, 50, 0)
    d2 = st.sidebar.number_input("Distancia 2", 0, 50, 30)
    title = st.sidebar.text_input("T√≠tulo personalizado")
    st.sidebar.subheader("Defensa")

    use_cov = st.sidebar.checkbox("Filtrar por Coverage", value=False)
    selected_cov = None
    if use_cov:
        covs = sorted(df["COVERAGE"].dropna().unique().tolist())
        selected_cov = st.sidebar.multiselect("Coverage", covs, default=covs)

    use_mof = st.sidebar.checkbox("Filtrar por MOF", value=False)
    selected_mof = None
    if use_mof:
        mofs = sorted(df["MOF"].dropna().unique().tolist())
        selected_mof = st.sidebar.multiselect("MOF", mofs, default=mofs)

    # --- Filtrado √öNICO para todo (resumen + mapa) ---
    df_plot = df.copy()

    # 1) Rivales
    if "RIVAL" in df_plot.columns and len(selected_rivals) > 0:
        df_plot = df_plot[df_plot["RIVAL"].astype(str).isin(selected_rivals)]
    else:
        st.warning("Selecciona al menos un RIVAL.")
        st.stop()

    df_plot = df_plot.copy()

    if preset == "1st & 10":
        df_plot = df_plot[
            (df_plot["DN"] == 1) &
            (df_plot["DIST"].between(9, 11))
        ]

    elif preset == "3rd & Long":
        df_plot = df_plot[
            (df_plot["DN"] == 3) &
            (df_plot["DIST"] >= 7)
        ]

    elif preset == "3rd & Short":
        df_plot = df_plot[
            (df_plot["DN"] == 3) &
            (df_plot["DIST"] <= 2)
        ]

    elif preset == "Red Zone":
        df_plot = df_plot[df_plot["SPOT Y 100"] >= 80]

    elif preset == "Backed Up":
        df_plot = df_plot[df_plot["SPOT Y 100"] <= 10]

    # All Plays ‚Üí no hace nada


    # All Plays ‚Üí no hace nada
    st.subheader(f"üìä {preset}")


    # 2) Coverage (si aplica)
    if use_cov and selected_cov:
        df_plot = df_plot[df_plot["COVERAGE"].isin(selected_cov)]

    # 3) MOF (si aplica)
    if use_mof and selected_mof:
        df_plot = df_plot[df_plot["MOF"].isin(selected_mof)]

    # 4) Down
    if down != "All":
        df_plot = df_plot[df_plot["DN"] == down]

    # 5) Distancia
    if distance_type == "Equal to":
        df_plot = df_plot[df_plot["DIST"] == d1]
    elif distance_type == "Greater than":
        df_plot = df_plot[df_plot["DIST"] >= d1]
    elif distance_type == "Less than":
        df_plot = df_plot[df_plot["DIST"] <= d1]
    elif distance_type == "Between":
        df_plot = df_plot[(df_plot["DIST"] >= d1) & (df_plot["DIST"] <= d2)]


    # Si no hay jugadas con esos filtros, avisa y corta
    if df_plot.empty:
        st.warning("No hay jugadas con esos filtros.")
        st.stop()

    # --- RESUMEN (CON df_plot) ---
    summary = compute_summary(df_plot)

    c1, c2, c3, c4, c5, c6 = st.columns(6)
    c1.metric("ATT", summary["att"])
    c2.metric("COMP", summary["comp"])
    c3.metric("COMP%", f'{summary["comp_pct"]:.1f}%')
    c4.metric("TD", summary["td"])
    c5.metric("INT", summary["int"])
    c6.metric("DROP", summary["drop"])
    st.caption(f'Avg Depth: {summary["avg_depth"]:.1f} yd')
    df_plot = df_plot.copy()
    df_plot["ROW_ID"] = df_plot.index.astype(int)  # id estable para resaltar
    if "selected_row_id" not in st.session_state:
        st.session_state.selected_row_id = None


    # ========= Placeholders (orden visual) =========
    map_container = st.container()      # arriba
    table_container = st.container()    # abajo

    # Si el seleccionado ya no existe con filtros, resetea
    if st.session_state.selected_row_id is not None:
        if st.session_state.selected_row_id not in set(df_plot["ROW_ID"].tolist()):
            st.session_state.selected_row_id = None

    # ========= TABLA + DETALLE (se ve abajo) =========
    with table_container:
        st.subheader("üìã Lista de jugadas (din√°mica)")

        candidate_cols = ["HUDL #", "RIVAL", "DN", "DIST", "SPOT Y 100", "TD/INT", "COM", "WR"]
        cols = [c for c in candidate_cols if c in df_plot.columns]

        plays_view = df_plot[cols + ["ROW_ID"]].copy()
        if "HUDL #" in plays_view.columns:
            plays_view["HUDL #"] = plays_view["HUDL #"].astype(str)

        event = st.dataframe(
            plays_view,
            use_container_width=True,
            hide_index=True,
            on_select="rerun",
            selection_mode="single-row",
            key="plays_table"   # key fijo para evitar glitches
        )

        if event and event.selection.rows:
            idx = event.selection.rows[0]
            st.session_state.selected_row_id = int(plays_view.iloc[idx]["ROW_ID"])

        st.subheader("üìù Detalle de jugada seleccionada")
        if st.session_state.selected_row_id is None:
            st.info("Selecciona una jugada de la tabla para ver el detalle y resaltarla en el mapa.")
        else:
            sel = df_plot[df_plot["ROW_ID"] == st.session_state.selected_row_id]
            if sel.empty:
                st.warning("La jugada seleccionada ya no existe con los filtros actuales.")
                st.session_state.selected_row_id = None
            else:
                r = sel.iloc[0]
                c1, c2, c3, c4, c5 = st.columns(5)
                if "DN" in df_plot.columns: c1.metric("Down", int(r["DN"]))
                if "DIST" in df_plot.columns: c2.metric("Dist", int(r["DIST"]))
                if "RIVAL" in df_plot.columns: c3.metric("Rival", str(r["RIVAL"]))
                if "HUDL #" in df_plot.columns: c4.metric("HUDL #", str(r["HUDL #"]))
                if "TD/INT" in df_plot.columns: c5.metric("Resultado", str(r["TD/INT"]))

    # ========= MAPA (se ve arriba, pero ya usa selection actual) =========
    with map_container:
        plot_football_passes(
            df_plot, down, distance_type, d1, d2, title,
            highlight_row_id=st.session_state.selected_row_id
        )




st.caption("‚ö†Ô∏è COVERAGE y MOF son simulados (demo) basados en down & distance.")
