
"""QB Chart.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rIIHTO-49-JFJMrMi087oR4rrYuBJUUw
"""
import streamlit as st
st.title("QB Pass Chart V0.3")

import matplotlib.pyplot as plt
import pandas as pd
from matplotlib.lines import Line2D



# Funci√≥n para dibujar el campo de f√∫tbol
def draw_football_field(ax):
    ax.set_facecolor('black')
    ax.plot([0, 53.3, 53.3, 0, 0], [-10, -10, 60, 60, -10], color='white', linewidth=2)

    for y in range(-10, 61, 10):
        ax.axhline(y, color='white', linewidth=1)

    for y in [-5, 5, 15, 25, 35, 45, 55]:
        ax.axhline(y, color='white', linewidth=0.75, linestyle='-')

    for y in [-10, 10, 20, 30, 40, 50, 60]:
        ax.text(8, y-0.84, f"{y}", fontsize=15, color='white', ha='center', rotation=270, linespacing=3.2)
        ax.text(45, y-0.42, f"{y}", fontsize=15, color='white', ha='center', rotation=90, linespacing=3.2)

    for y in range(-10, 61):
        if y % 5 != 0:
            ax.plot([19, 20], [y, y], color='white', linewidth=1)
            ax.plot([33, 34], [y, y], color='white', linewidth=1)

def compute_summary(df_in: pd.DataFrame) -> dict:
    if df_in is None or df_in.empty:
        return {"att": 0, "comp": 0, "comp_pct": 0.0, "td": 0, "int": 0, "drop": 0, "avg_depth": 0.0}

    df2 = df_in.copy()
    df2["DEPTH"] = df2["Target Y 100"] - df2["SPOT Y 100"]

    att = len(df2)
    comp = int((df2["COM"] == 1).sum()) if "COM" in df2.columns else 0
    comp_pct = (comp / att * 100) if att > 0 else 0.0

    outcome = df2["TD/INT"].astype(str).str.upper().str.strip() if "TD/INT" in df2.columns else pd.Series([""] * att)
    td = int((outcome == "TD").sum())
    it = int((outcome == "INT").sum())
    drop = int((outcome == "DROP").sum())

    avg_depth = float(df2["DEPTH"].mean()) if att > 0 else 0.0

    return {"att": att, "comp": comp, "comp_pct": comp_pct, "td": td, "int": it, "drop": drop, "avg_depth": avg_depth}

import numpy as np

rng = np.random.default_rng(42)  # cambia el 42 si quieres otra ‚Äútemporada‚Äù

def assign_coverage(row):
    dn = row.get("DN", None)
    dist = row.get("DIST", None)

    # si falta info, usa distribuci√≥n base
    if pd.isna(dn) or pd.isna(dist):
        return rng.choice(
            ["Cover 3", "Cover 1", "Cover 2", "Cover 4", "Cover 6", "Blitz", "2 Man", "Cover 0"],
            p=[0.30, 0.20, 0.15, 0.12, 0.08, 0.07, 0.05, 0.03]
        )

    dn = int(dn)
    dist = float(dist)

    # 3rd/4th & long: m√°s 2-high / quarters / split safety
    if dn in (3, 4) and dist >= 7:
        return rng.choice(
            ["Cover 2", "Cover 4", "Cover 6", "2 Man", "Cover 3", "Cover 1", "Blitz"],
            p=[0.22, 0.26, 0.16, 0.10, 0.12, 0.08, 0.06]
        )

    # 3rd/4th & short: m√°s man, presi√≥n, single-high
    if dn in (3, 4) and dist <= 2:
        return rng.choice(
            ["Cover 1", "Blitz", "Cover 0", "Cover 3", "2 Man"],
            p=[0.40, 0.30, 0.12, 0.12, 0.06]
        )

    # 1st down: mucho Cover 3 / 1, algo de 2/4
    if dn == 1:
        return rng.choice(
            ["Cover 3", "Cover 1", "Cover 2", "Cover 4", "Cover 6", "Blitz", "2 Man", "Cover 0"],
            p=[0.34, 0.22, 0.14, 0.12, 0.07, 0.06, 0.03, 0.02]
        )

    # 2nd down: mezcla
    return rng.choice(
        ["Cover 3", "Cover 1", "Cover 2", "Cover 4", "Cover 6", "Blitz", "2 Man", "Cover 0"],
        p=[0.30, 0.20, 0.16, 0.12, 0.08, 0.08, 0.04, 0.02]
    )

def coverage_to_mof(cov: str) -> str:
    """
    MOF Open ~ 2-high structures (Cover 2/4/6, 2 Man).
    MOF Closed ~ 1-high/0-high (Cover 1/3/0).
    Blitz puede ser cualquiera; aqu√≠ lo tratamos mayormente Closed pero a veces Open.
    """
    c = str(cov).strip().lower()

    if c in ("cover 2", "cover 4", "cover 6", "2 man"):
        return "Open"
    if c in ("cover 0", "cover 1", "cover 3"):
        return "Closed"
    if c == "blitz":
        # 70% single-high (Closed), 30% 2-high pressures (Open)
        return rng.choice(["Closed", "Open"], p=[0.70, 0.30])

    return "Unknown"



# Funci√≥n para graficar los pases filtrados
def plot_football_passes(df, down, distance_type, d1, d2, custom_title):

    fig, ax = plt.subplots(figsize=(8, 8))
    draw_football_field(ax)

    ax.set_xlim(0, 53.3)
    ax.set_ylim(-10, 60)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.axhline(0, color='blue', linewidth=2)
    ax.set_aspect('equal')

    title = custom_title if custom_title else f"Pass Chart ‚Äì Down {down}"
    ax.set_title(title)

    for _, row in df.iterrows():
        x = row['Target X 100']
        y = row['Target Y 100'] - row['SPOT Y 100']
        ax.scatter(x, y, color=row['Color'], s=80)

        if 'WR' in df.columns and not pd.isna(row['WR']):
            ax.text(x, y, str(int(row['WR'])), fontsize=6,
                    ha='center', va='center', color='black')

    legend_elements = [
        Line2D([0], [0], marker='o', color='w', label='Completo', markerfacecolor='aqua', markersize=8),
        Line2D([0], [0], marker='o', color='w', label='Incompleto', markerfacecolor='fuchsia', markersize=8),
        Line2D([0], [0], marker='o', color='w', label='Intercepci√≥n', markerfacecolor='red', markersize=8),
        Line2D([0], [0], marker='o', color='w', label='Touchdown', markerfacecolor='lime', markersize=8),
        Line2D([0], [0], marker='o', color='w', label='Drop', markerfacecolor='yellow', markersize=8),
    ]
    leg = ax.legend(handles=legend_elements, loc='upper right',
                    frameon=True, facecolor='black', edgecolor='white')
    for t in leg.get_texts():
        t.set_color('white')

    st.pyplot(fig)

st.title("üèà Pass Chart Interactivo")

uploaded_file = st.file_uploader("Sube tu archivo CSV o Excel", type=["csv", "xlsx"])

if uploaded_file:
    df = pd.read_csv(uploaded_file) if uploaded_file.name.endswith(".csv") else pd.read_excel(uploaded_file)
    df.columns = df.columns.str.strip()
    df = df.dropna(subset=['Target X 100', 'Target Y 100'])
    df["COM"] = df["COM"].fillna(0)
    # Crear columnas (si ya existen, esto las sobreescribe para el demo)
    df["COVERAGE"] = df.apply(assign_coverage, axis=1)
    df["MOF"] = df["COVERAGE"].apply(coverage_to_mof)
    def get_color(row):
        outcome = str(row.get("TD/INT", "")).strip()
        if outcome == 'TD':
            return 'lime'
        elif outcome == 'INT':
            return 'red'
        elif outcome == 'Drop':
            return 'yellow'
        elif float(row.get("COM", 0)) == 1.0:
            return 'aqua'
        else:
            return 'fuchsia'

    df['Color'] = df.apply(get_color, axis=1)

    # --- Sidebar ---
    st.sidebar.header("Filtros")
    st.sidebar.subheader("Partidos (RIVAL)")

    rivals = sorted(df["RIVAL"].dropna().astype(str).unique().tolist()) if "RIVAL" in df.columns else []
    selected_rivals = st.sidebar.multiselect(
        "Selecciona partido(s) por RIVAL",
        options=rivals,
        default=rivals
    )

    down = st.sidebar.selectbox("Down", ["All"] + sorted(df['DN'].unique()))
    distance_type = st.sidebar.selectbox("Tipo de distancia", ["Greater than", "Equal to", "Less than", "Between"])
    d1 = st.sidebar.number_input("Distancia 1", 0, 50, 0)
    d2 = st.sidebar.number_input("Distancia 2", 0, 50, 30)
    title = st.sidebar.text_input("T√≠tulo personalizado")
    st.sidebar.subheader("Defensa")

    use_cov = st.sidebar.checkbox("Filtrar por Coverage", value=False)
    selected_cov = None
    if use_cov:
        covs = sorted(df["COVERAGE"].dropna().unique().tolist())
        selected_cov = st.sidebar.multiselect("Coverage", covs, default=covs)

    use_mof = st.sidebar.checkbox("Filtrar por MOF", value=False)
    selected_mof = None
    if use_mof:
        mofs = sorted(df["MOF"].dropna().unique().tolist())
        selected_mof = st.sidebar.multiselect("MOF", mofs, default=mofs)

    # --- Filtrado √öNICO para todo (resumen + mapa) ---
    df_plot = df.copy()

    # 1) Rivales
    if "RIVAL" in df_plot.columns and len(selected_rivals) > 0:
        df_plot = df_plot[df_plot["RIVAL"].astype(str).isin(selected_rivals)]
    else:
        st.warning("Selecciona al menos un RIVAL.")
        st.stop()

    # 2) Coverage (si aplica)
    if use_cov and selected_cov:
        df_plot = df_plot[df_plot["COVERAGE"].isin(selected_cov)]

    # 3) MOF (si aplica)
    if use_mof and selected_mof:
        df_plot = df_plot[df_plot["MOF"].isin(selected_mof)]

    # 4) Down
    if down != "All":
        df_plot = df_plot[df_plot["DN"] == down]

    # 5) Distancia
    if distance_type == "Equal to":
        df_plot = df_plot[df_plot["DIST"] == d1]
    elif distance_type == "Greater than":
        df_plot = df_plot[df_plot["DIST"] >= d1]
    elif distance_type == "Less than":
        df_plot = df_plot[df_plot["DIST"] <= d1]
    elif distance_type == "Between":
        df_plot = df_plot[(df_plot["DIST"] >= d1) & (df_plot["DIST"] <= d2)]


    # Si no hay jugadas con esos filtros, avisa y corta
    if df_plot.empty:
        st.warning("No hay jugadas con esos filtros.")
        st.stop()

    # --- RESUMEN (CON df_plot) ---
    summary = compute_summary(df_plot)

    c1, c2, c3, c4, c5, c6 = st.columns(6)
    c1.metric("ATT", summary["att"])
    c2.metric("COMP", summary["comp"])
    c3.metric("COMP%", f'{summary["comp_pct"]:.1f}%')
    c4.metric("TD", summary["td"])
    c5.metric("INT", summary["int"])
    c6.metric("DROP", summary["drop"])
    st.caption(f'Avg Depth: {summary["avg_depth"]:.1f} yd')

    # --- MAPA (CON df_plot) ---
    plot_football_passes(df_plot, down, distance_type, d1, d2, title)


st.caption("‚ö†Ô∏è COVERAGE y MOF son simulados (demo) basados en down & distance.")
